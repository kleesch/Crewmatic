# Among Us Bot

The Among Us Bot is a Java-based automatic completion bot. Made for Innersloth's popular game Among Us, the bot was intended as a design challenge for myself to learn more java computing principles. These include: rudimentary screen sampling, multi-threading fundamentals, task automation, and pathing algorithms.

# Design Challenges

As this was a design challenge project, I thought it would be helpful to outline some of the complications with the project, as well as my solutions to them. While not all of these problems are reflected in commits, they are all very pertinent problems that I have faced along the way.

1. Problem: Accurate Identification. When I first started this project, I had originally designed it as an assisting bot (doing some of the gameplay while the player does the other). For this to work, I had to ensure that the bot could readily identify certain pixels correctly in a relatively fast way. I solved this in a variety of ways. For static images, choosing unique pixels of interest to test was a simple solution. For game-generated images that change between contexts however, I opted for a more complex solution in thresholding. The use of thresholding allowed me to test pixels much quicker, as in most cases iteration could check general areas instead of specifically every pixel.

2. Problem: Imprecise Behavior. When I first experimented with Java's Robot class, I quickly found that lots of my tests yielded different results over time. This is of course a problem, as for any automation we want the results to be as accurate (and thus, successful) as possible. There were two specific instances where this became an issue. The first, in random mouse movement. This was a simple one to solve: as a documented behavioural issue in some use contexts, there have been solutions proposed to this by other programmers. After some research, I deciced that attempting a mouse movement multiple times and checking to confirm its location before use worked just fine. While this can take more computational resources in niche cases than more complex solutions, in general the simpler case was also faster. The second instance in which I had this issue was in player movement. User-simulated movement could not be achieved with complete accuracy, and player-location detection could not be run in a computationally inexpensive way. The first method to solving this came with data collection, in which several trials were performed to generate an average player movement. While this appears sufficient for now, I have other solutions prepared.

3. Problem: Mapping Time. When I decided that I wanted the bot to replicate player movement, I committed to the creation of a graph of supported maps to use in conjunction with Dijkstra's algorithm. I quickly found out, however, that any graph would consist of nearly a hundred nodes and many more edges. While there are certainly instances in which I would be willing to map such graphs by hand, I favored an alternative approach in this instance. When I drew the first graph initially, I knew that I wanted the player to move in one coordinate direction at a time to ensure movement accuracy. This made it quite simple to infer the location of nodes and edges from a graphical form. This graphical form could be computationally analyzed by any image processing. For this case, I opted to use image-js, a package within node.js. This simplified mapping time dramatically, and allowed for adjustments to be easily made in cases where needed. This program also generated the appropriate java code for each node and edge, as well as a labelled map for programmer ease of use.
